import struct
import numpy as np

# Author: Damian Mendroch,
# Project repository: https://github.com/drocheam/musurf-reader

"""
Functions for importing files of the nanofocus usurf microscope
Supports only the OM_MS_2.0 file versions.

supported formats:
.nms:       support of x and y coordinates, image and intensity data
.orginal:   same file structure as .nms
.txt:       support of x and y coordinates and image data
.sms:       support of x and y coordinates, image and intensity data for each individual image
.smt:       same file structure as .sms
.smi:       support of image count in x and y direction as well as the overlap parameter
"""


def checktype(string, comp):
    """
    raises an exception when the file extension is incorrect

    :param string: input path or filename, must contain extension at the end (string)
    :param comp: extension to compare to (string)
    """
    if string[-len(comp):] != comp:
        raise Exception("Incorrect file type, expected " + comp)


def readtxt(path):
    """
    loads ascii table file (.txt) generated by µsoft

    :param path: path to file (string)
    :return: x coordinate vector (1D numpy array), y coordinate vector (1D numpy array) and z values (2D numpy array)
    """
    checktype(path, ".txt")

    data = np.genfromtxt(path, delimiter='\t', skip_header=True)

    x = data[0, 1:-1]
    y = data[1:, 0]
    h_data = data[1:, 1:-1]

    return x, y, h_data


def readsmi(path):
    """
    loads µsoft .smi file and reads stitching preferences

    :param path: smi file location (string)
    :return: stitching preferences dictionary (see code for details)
    """
    checktype(path, ".smi")
    data = np.fromfile(path, dtype='ubyte')

    # this parameters are experimental, since they are not in the documentation
    nx = struct.unpack('<i', data[40:44])[0]
    ny = struct.unpack('<i', data[44:48])[0]
    ovlp = struct.unpack('<i', data[48:52])[0]

    return nx, ny, ovlp



def readsms(path):
    """
    loads µsoft .sms file and reads image and intensity data

    :param path: sms file location (string)
    :return: x coordinate vector (1D array), y coordinate vector (1D array),
        Images: height images (list of 2D array),
        intensity:  intensity images (list of 2D array)
    """
    checktype(path, ".sms")
    return readImages(path, single=False)



def readsmt(path):
    """
    loads µsoft .smt file and reads image and intensity data

    :param path: smt file location (string)
    :return: x coordinate vector (1D array), y coordinate vector (1D array),
        Images: height images (list of 2D array),
        intensity:  intensity images (list of 2D array)
    """
    checktype(path, ".smt")
    return readImages(path, single=False)



def readnms(path):
    """
    loads µsoft .nms file and reads image and intensity data

    :param path: nms file location (string)
    :return: x coordinate vector (numpy 1D array), y coordinate vector (numpy 1D array),
        Image: height image (numpy 2D array),
        intensity:  intensity image (numpy 2D array)
    """
    checktype(path, ".nms")
    x, y, images, intensities = readImages(path, single=True)
    return x, y, images[0], intensities[0]



def readorginal(path):
    """
    loads µsoft .orginal file and reads image and intensity data

    :param path: .orginal file location (string)
    :return: x coordinate vector (numpy 1D array), y coordinate vector (numpy 1D array),
        Image: height image (numpy 2D array),
        intensity:  intensity image (numpy 2D array)
    """
    checktype(path, ".orginal")
    x, y, images, intensities = readImages(path, single=True)
    return x, y, images[0], intensities[0]



def readImages(path, single):
    """
    reads binary .smt and .sms files as generated by µsoft

    :param path: path to file (string)
    :param single:
    :return: x coordinate vector (1D array), y coordinate vector (1D array),
        Images: height images (list of 2D array),
        intensity:  intensity images (list of 2D array)
    """

    data = np.fromfile(path, dtype='ubyte')

    # set parameters depending on filetype (stitched image or individual images)
    if single:
        HS = -116 # relative header size
        ImHS = 3584 # image header size
        nImages = 1 # number of images
    else:
        HS = 1344
        ImHS = 1536
        nImages = data[4]

    # nx, ny, dx, dy and has_intensity are included for each image, but we read them once
    # and assume they're the same for all the images, which should be always the case

    datatype = data[HS+116] # 2: unsigned short
    dimensiontype = data[HS+120] # 0: 1D Profile, 1: 2D area
    version =  "".join(list(map(chr, data[HS+148:HS+157]))) # version string

    if datatype != 2:
        raise Exception("Data type not supported")
    if dimensiontype != 1:
        raise Exception("Dimension type not supported")
    if version != "OM_MS_2.0":
        raise Exception("File format version not supported")

    # number of lines and columns per image
    nx = struct.unpack('<i', data[HS+1484 : HS+1488])[0]
    ny = struct.unpack('<i', data[HS+1488 : HS+1492])[0]

    # step size in um
    dx = struct.unpack('<d', data[HS+1492 : HS+1500])[0] / 1000.0
    dy = struct.unpack('<d', data[HS+1500 : HS+1508])[0] / 1000.0

    # intensities included ?
    has_intensity = struct.unpack('<i', data[HS+1532 : HS+1536])[0] > 0

    DPS = 2  # datapoint size (short)
    IDS = nx * ny * DPS  # size of image data in bytes

    # initialize lists and vectors
    images = []
    intensities = []
    x = np.arange(0, nx*dx, dx)
    y = np.arange(0, ny*dy, dy)

    # data starting position of first image
    off = HS

    for n in np.arange(nImages):

        # read data conversion parameters
        n_low = struct.unpack('<i', data[off+124:off+128])[0]
        n_high = struct.unpack('<i', data[off+128:off+132])[0]
        f_low = struct.unpack('<d', data[off+132:off+140])[0]
        f_high = struct.unpack('<d', data[off+140:off+148])[0]

        # binary ushort data to numpy float array
        image = data[off+ImHS:off+ImHS+IDS] # data region
        image = image[1::2]*256 + image[::2] # ushort to int, ~40x faster than using list() and struct.iter_unpack('<H')
        image = f_low + (f_high - f_low)/(n_high-n_low) * image # calculate scaled float values

        # use intensity to mask out bad values
        if has_intensity:
            intensity = data[off+ImHS+IDS:off+ImHS+IDS+nx*ny]
            image[intensity==0] = np.nan
            intensity = np.array(intensity)
            intensities.append(intensity.reshape((ny, nx)))

        # make 2D matrix from vector and append
        image = image.reshape((ny, nx))
        images.append(image)

        # set start of next image
        off += ImHS + IDS + ny*nx*has_intensity

    return x, y, images, intensities